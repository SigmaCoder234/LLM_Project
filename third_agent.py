#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
=============================================================================
–ß–ê–¢-–ê–ì–ï–ù–¢ ‚Ññ3 —Å PostgreSQL - –ú–æ–¥–µ—Ä–∞—Ç–æ—Ä (GigaChat)
=============================================================================
- –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –º–æ–¥–µ–ª–∏ –ë–î –∏–∑ first_agent.py  
- –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å PostgreSQL —á–µ—Ä–µ–∑ SQLAlchemy ORM
- GigaChat –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –Ω–∞—Ä—É—à–µ–Ω–∏–π
- Redis –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∑–∞–¥–∞—á –æ—Ç –∞–≥–µ–Ω—Ç–∞ 2
=============================================================================
"""

import asyncio
import json
import os
import time
import uuid
from datetime import datetime
from typing import Any, Dict, List, Optional

import httpx
import redis
from loguru import logger

# SQLAlchemy imports - –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ –∂–µ –º–æ–¥–µ–ª–∏ —á—Ç–æ –∏ –≤ –ø–µ—Ä–≤–æ–º –∞–≥–µ–Ω—Ç–µ
from sqlalchemy import create_engine, select
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker
from sqlalchemy.orm import sessionmaker
from sqlalchemy.sql import func

# –û–±—â–∏–µ –º–æ–¥–µ–ª–∏ –ë–î - —Ç–µ –∂–µ —á—Ç–æ –≤ first_agent.py –∏ teteguard_bot.py
from sqlalchemy import Column, Integer, BigInteger, String, Text, Boolean, ForeignKey, DateTime, JSON
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship

Base = declarative_base()

class Chat(Base):
    __tablename__ = "chats"
    id = Column(Integer, primary_key=True)
    tg_chat_id = Column(String, unique=True, nullable=False)
    messages = relationship('Message', back_populates='chat', cascade="all, delete")
    moderators = relationship('Moderator', back_populates='chat', cascade="all, delete")
    negative_messages = relationship('NegativeMessage', back_populates='chat', cascade="all, delete")

class Message(Base):
    __tablename__ = "messages"
    id = Column(Integer, primary_key=True)
    chat_id = Column(Integer, ForeignKey('chats.id'), nullable=False)
    sender_username = Column(String)
    sender_id = Column(BigInteger)
    message_text = Column(String)
    message_link = Column(String)
    created_at = Column(DateTime, default=func.now())
    chat = relationship('Chat', back_populates='messages')

class Moderator(Base):
    __tablename__ = "moderators"
    id = Column(Integer, primary_key=True)
    chat_id = Column(Integer, ForeignKey('chats.id'), nullable=False)
    username = Column(String)
    telegram_user_id = Column(BigInteger)
    chat = relationship('Chat', back_populates='moderators')

class NegativeMessage(Base):
    __tablename__ = "negative_messages"
    id = Column(Integer, primary_key=True)
    chat_id = Column(Integer, ForeignKey('chats.id'), nullable=False)
    message_link = Column(String)
    sender_username = Column(String)
    negative_reason = Column(String)
    is_sent_to_moderators = Column(Boolean, default=False)
    created_at = Column(DateTime, default=func.now())
    chat = relationship('Chat', back_populates='negative_messages')

# =========================
# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
# =========================
from pathlib import Path
Path("logs").mkdir(exist_ok=True)

logger.remove()
logger.add(
    "logs/agent_3_{time:YYYY-MM-DD}.log",
    rotation="1 day",
    retention="30 days", 
    level="INFO",
    format="{time:YYYY-MM-DD HH:mm:ss} | {level} | {name}:{function}:{line} | {message}"
)
logger.add(lambda msg: print(msg, end=""), level="INFO", format="{time:HH:mm:ss} | {level} | {message}")

# =========================
# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
# =========================
class Agent3Config:
    # PostgreSQL –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ - —Ç–µ –∂–µ —á—Ç–æ –≤ teteguard_bot.py
    POSTGRES_HOST = "176.108.248.211"
    POSTGRES_PORT = 5432
    POSTGRES_DB = "teleguard_db" 
    POSTGRES_USER = "tguser"
    POSTGRES_PASSWORD = "mnvm7110"
    
    # Redis –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
    REDIS_HOST = "localhost"
    REDIS_PORT = 6379
    REDIS_DB = 0
    REDIS_PASSWORD = None
    
    # –û—á–µ—Ä–µ–¥–∏ Redis
    QUEUE_INPUT = "queue:agent3:input"
    QUEUE_OUTPUT = "queue:agent3:output"
    
    # GigaChat
    GIGACHAT_AUTH_URL = "https://ngw.devices.sberbank.ru:9443/api/v2/oauth"
    GIGACHAT_API_URL = "https://gigachat.devices.sberbank.ru/api/v1"
    DEFAULT_GIGACHAT_CREDENTIALS = "MDE5YTJhZjEtYjhjOS03OTViLWFlZjEtZTg4MTgxNjQzNzdjOmE0MzRhNjExLTE2NGYtNDdjYS1iNTM2LThlMGViMmU0YzVmNg=="
    
    @property
    def database_url(self) -> str:
        return f"postgresql+asyncpg://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}@{self.POSTGRES_HOST}:{self.POSTGRES_PORT}/{self.POSTGRES_DB}"
    
    @property  
    def sync_database_url(self) -> str:
        return f"postgresql://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}@{self.POSTGRES_HOST}:{self.POSTGRES_PORT}/{self.POSTGRES_DB}"

# =========================
# GigaChat Client
# =========================
class GigaChatClient:
    def __init__(self, credentials: str):
        self.credentials = credentials
        self.access_token: Optional[str] = None
        self.token_expires_at: Optional[datetime] = None
        logger.info("üîß GigaChat –∫–ª–∏–µ–Ω—Ç –∞–≥–µ–Ω—Ç–∞ 3 –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    
    async def get_access_token(self) -> str:
        if (self.access_token and self.token_expires_at and 
            datetime.now() < self.token_expires_at):
            return self.access_token
        
        payload = {'scope': 'GIGACHAT_API_PERS'}
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded',
            'Accept': 'application/json',
            'RqUID': str(uuid.uuid4()),
            'Authorization': f'Basic {self.credentials}'
        }
        
        try:
            async with httpx.AsyncClient(verify=False, timeout=15.0) as client:
                response = await client.post(Agent3Config.GIGACHAT_AUTH_URL, headers=headers, data=payload)
                response.raise_for_status()
                token_data = response.json()
                
                self.access_token = token_data['access_token']
                expires_in = token_data.get('expires_in', 1800)
                from datetime import timedelta
                self.token_expires_at = datetime.now() + timedelta(seconds=expires_in - 60)
                
                logger.success(f"üîë –ê–≥–µ–Ω—Ç 3 –ø–æ–ª—É—á–∏–ª –Ω–æ–≤—ã–π —Ç–æ–∫–µ–Ω GigaChat")
                return self.access_token
        except Exception as e:
            logger.error(f"‚ùå –ê–≥–µ–Ω—Ç 3: –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞ GigaChat: {e}")
            raise
    
    async def moderate_message(self, message_text: str, rules: List[str]) -> Dict[str, Any]:
        """–ú–æ–¥–µ—Ä–∞—Ü–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è —á–µ—Ä–µ–∑ GigaChat"""
        token = await self.get_access_token()
        
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
            "Accept": "application/json",
        }
        
        rules_text = "\n".join([f"{i+1}. {rule}" for i, rule in enumerate(rules)])
        system_prompt = f"""–¢—ã ‚Äî —Å—Ç—Ä–æ–≥–∏–π, –Ω–æ —Å–ø—Ä–∞–≤–µ–¥–ª–∏–≤—ã–π –º–æ–¥–µ—Ä–∞—Ç–æ—Ä Telegram-–∫–∞–Ω–∞–ª–∞.
        –¢–≤–æ—è –∑–∞–¥–∞—á–∞: –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, –Ω–∞—Ä—É—à–∞–µ—Ç –ª–∏ –æ–Ω–æ –ø—Ä–∞–≤–∏–ª–∞ —á–∞—Ç–∞.
        
        –ò–ù–°–¢–†–£–ö–¶–ò–Ø:
        1. –í–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ –∏–∑—É—á–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ
        2. –°—Ä–∞–≤–Ω–∏ –µ–≥–æ —Å –∫–∞–∂–¥—ã–º –ø—Ä–∞–≤–∏–ª–æ–º
        3. –ï—Å–ª–∏ –Ω–∞–π–¥–µ–Ω–æ –Ω–∞—Ä—É—à–µ–Ω–∏–µ ‚Äî —É–∫–∞–∂–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–µ –ø—Ä–∞–≤–∏–ª–æ –∏ –æ–±—ä—è—Å–Ω–∏ –ø–æ—á–µ–º—É
        4. –ï—Å–ª–∏ —Å–æ–º–Ω–µ–≤–∞–µ—à—å—Å—è ‚Äî –ª—É—á—à–µ –Ω–µ –±–∞–Ω–∏—Ç—å (–ø—Ä–µ–∑—É–º–ø—Ü–∏—è –Ω–µ–≤–∏–Ω–æ–≤–Ω–æ—Å—Ç–∏)
        5. –ë—É–¥—å –æ–±—ä–µ–∫—Ç–∏–≤–Ω—ã–º
        
        –ü—Ä–∞–≤–∏–ª–∞ —á–∞—Ç–∞:
        {rules_text}
        
        –û—Ç–≤–µ—Ç—å –°–¢–†–û–ì–û –≤ —Ñ–æ—Ä–º–∞—Ç–µ: '–í–µ—Ä–¥–∏–∫—Ç: –¥–∞/–Ω–µ—Ç. –ü—Ä–∏—á–∏–Ω–∞: [–ø–æ–¥—Ä–æ–±–Ω–æ–µ –æ–±—ä—è—Å–Ω–µ–Ω–∏–µ]'"""
        
        payload = {
            "model": "GigaChat",
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": f"–ê–Ω–∞–ª–∏–∑–∏—Ä—É–π —Å–æ–æ–±—â–µ–Ω–∏–µ: {message_text}"}
            ],
            "temperature": 0.2,  # –ù–∏–∑–∫–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
            "max_tokens": 256,
            "stream": False,
        }
        
        try:
            async with httpx.AsyncClient(verify=False, timeout=30.0) as client:
                response = await client.post(f"{Agent3Config.GIGACHAT_API_URL}/chat/completions", 
                                           headers=headers, json=payload)
                response.raise_for_status()
                result = response.json()
                
                if result.get("choices") and len(result["choices"]) > 0:
                    content = result["choices"][0]["message"]["content"].strip()
                    
                    # –ü–∞—Ä—Å–∏–º –æ—Ç–≤–µ—Ç GigaChat
                    content_lower = content.lower()
                    
                    # –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –≤–µ—Ä–¥–∏–∫—Ç–∞
                    ban_keywords = ["–≤–µ—Ä–¥–∏–∫—Ç: –¥–∞", "–Ω–∞—Ä—É—à–µ–Ω–∏–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ", "–Ω–∞—Ä—É—à–∞–µ—Ç –ø—Ä–∞–≤–∏–ª–∞", "–∑–∞–±–∞–Ω–∏—Ç—å", "–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å"]
                    no_ban_keywords = ["–≤–µ—Ä–¥–∏–∫—Ç: –Ω–µ—Ç", "–Ω–µ—Ç –Ω–∞—Ä—É—à–µ–Ω–∏–π", "–Ω–µ –Ω–∞—Ä—É—à–∞–µ—Ç", "–ø—Ä–∞–≤–∏–ª–∞ —Å–æ–±–ª—é–¥–µ–Ω—ã", "–Ω–∞—Ä—É—à–µ–Ω–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ"]
                    
                    ban = False
                    # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –Ω–∞—Ä—É—à–µ–Ω–∏–π (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)
                    if any(word in content_lower for word in no_ban_keywords):
                        ban = False
                    # –ó–∞—Ç–µ–º –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –Ω–∞—Ä—É—à–µ–Ω–∏–π
                    elif any(word in content_lower for word in ban_keywords):
                        ban = True
                    
                    return {
                        "ban": ban,
                        "reason": content,
                        "confidence": 0.85 if ban else 0.8
                    }
                else:
                    return {"ban": False, "reason": "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç –æ—Ç GigaChat", "confidence": 0.0}
        except Exception as e:
            logger.error(f"‚ùå –ê–≥–µ–Ω—Ç 3: –û—à–∏–±–∫–∞ –º–æ–¥–µ—Ä–∞—Ü–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")
            return {"ban": False, "reason": f"–û—à–∏–±–∫–∞ GigaChat: {str(e)}", "confidence": 0.0}

# =========================
# Database Manager
# =========================
class Agent3DatabaseManager:
    def __init__(self, config: Agent3Config):
        self.config = config
        self.engine = None
        self.async_session_factory = None
    
    async def init_database(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è PostgreSQL –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
        try:
            # –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
            sync_engine = create_engine(self.config.sync_database_url, echo=False)
            Base.metadata.create_all(sync_engine)
            sync_engine.dispose()
            
            # –°–æ–∑–¥–∞–Ω–∏–µ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –¥–≤–∏–∂–∫–∞ PostgreSQL
            self.engine = create_async_engine(
                self.config.database_url,
                echo=False,
                future=True,
                pool_pre_ping=True,
                pool_recycle=3600
            )
            
            self.async_session_factory = async_sessionmaker(
                self.engine,
                class_=AsyncSession,
                expire_on_commit=False
            )
            
            logger.success(f"üóÑÔ∏è –ê–≥–µ–Ω—Ç 3: PostgreSQL –ë–î –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
        except Exception as e:
            logger.error(f"‚ùå –ê–≥–µ–Ω—Ç 3: –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ PostgreSQL: {e}")
            raise
    
    async def close_database(self):
        if self.engine:
            await self.engine.dispose()
            logger.info("üóÑÔ∏è –ê–≥–µ–Ω—Ç 3: –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å PostgreSQL –∑–∞–∫—Ä—ã—Ç–æ")
    
    def get_session(self) -> AsyncSession:
        if not self.async_session_factory:
            raise RuntimeError("PostgreSQL database not initialized")
        return self.async_session_factory()

# =========================
# Redis Worker
# =========================  
class Agent3RedisWorker:
    def __init__(self, config: Agent3Config):
        self.config = config
        self.gigachat = GigaChatClient(
            os.getenv("GIGACHAT_CREDENTIALS", config.DEFAULT_GIGACHAT_CREDENTIALS)
        )
        self.db = Agent3DatabaseManager(config)
        self.processed_count = 0
        
        # –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Redis
        try:
            self.redis_client = redis.Redis(
                host=config.REDIS_HOST,
                port=config.REDIS_PORT,
                db=config.REDIS_DB,
                password=config.REDIS_PASSWORD,
                decode_responses=True
            )
            self.redis_client.ping()
            logger.success(f"üîó –ê–≥–µ–Ω—Ç 3: Redis –ø–æ–¥–∫–ª—é—á–µ–Ω {config.REDIS_HOST}:{config.REDIS_PORT}")
        except Exception as e:
            logger.error(f"‚ùå –ê–≥–µ–Ω—Ç 3: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ Redis: {e}")
            raise
    
    async def process_message(self, message_data: str) -> Dict[str, Any]:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–¥–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ –æ—á–µ—Ä–µ–¥–∏"""
        try:
            # –ü–∞—Ä—Å–∏–º JSON
            input_data = json.loads(message_data)
            
            # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ
            message = input_data.get("message", "")
            rules = input_data.get("rules", [])
            user_id = input_data.get("user_id")
            username = input_data.get("username")
            chat_id = input_data.get("chat_id")
            message_id = input_data.get("message_id")
            
            # –í–∞–ª–∏–¥–∞—Ü–∏—è
            if not message:
                return {
                    "agent_id": 3,
                    "ban": False,
                    "reason": "–û—à–∏–±–∫–∞: –ø—É—Å—Ç–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ",
                    "message": "",
                    "user_id": user_id,
                    "username": username,
                    "chat_id": chat_id,
                    "message_id": message_id
                }
            
            if not rules:
                return {
                    "agent_id": 3,
                    "ban": False,
                    "reason": "–û—à–∏–±–∫–∞: –ø—Ä–∞–≤–∏–ª–∞ –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω—ã",
                    "message": message,
                    "user_id": user_id,
                    "username": username,
                    "chat_id": chat_id,
                    "message_id": message_id
                }
            
            logger.info(f"[–ê–ì–ï–ù–¢ 3] –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Å–æ–æ–±—â–µ–Ω–∏–µ: {message[:50]}...")
            
            # –ú–æ–¥–µ—Ä–∞—Ü–∏—è —á–µ—Ä–µ–∑ GigaChat
            moderation_result = await self.gigachat.moderate_message(message, rules)
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            result = {
                "agent_id": 3,
                "ban": moderation_result["ban"],
                "reason": moderation_result["reason"],
                "message": message,
                "user_id": user_id,
                "username": username,
                "chat_id": chat_id,
                "message_id": message_id,
                "confidence": moderation_result["confidence"],
                "timestamp": datetime.now().isoformat()
            }
            
            self.processed_count += 1
            logger.success(f"[–ê–ì–ï–ù–¢ 3] –í–µ—Ä–¥–∏–∫—Ç: {'–ë–ê–ù' if moderation_result['ban'] else '–ù–ï –ë–ê–ù–ò–¢–¨'}")
            
            return result
            
        except json.JSONDecodeError as e:
            logger.error(f"‚ùå –ê–≥–µ–Ω—Ç 3: –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π JSON: {e}")
            return {
                "agent_id": 3,
                "ban": False,
                "reason": f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–∞–Ω–Ω—ã—Ö: {e}",
                "message": ""
            }
        except Exception as e:
            logger.error(f"‚ùå –ê–≥–µ–Ω—Ç 3: –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")
            return {
                "agent_id": 3,
                "ban": False,
                "reason": f"–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ –∞–≥–µ–Ω—Ç–∞ 3: {e}",
                "message": ""
            }
    
    def send_result(self, result: Dict[str, Any]) -> None:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –≤ –≤—ã—Ö–æ–¥–Ω—É—é –æ—á–µ—Ä–µ–¥—å"""
        try:
            result_json = json.dumps(result, ensure_ascii=False)
            self.redis_client.rpush(self.config.QUEUE_OUTPUT, result_json)
            logger.success(f"üì§ –ê–≥–µ–Ω—Ç 3: –†–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ {self.config.QUEUE_OUTPUT}")
        except Exception as e:
            logger.error(f"‚ùå –ê–≥–µ–Ω—Ç 3: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {e}")
    
    async def run(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π"""
        await self.db.init_database()
        
        logger.info(f"üöÄ –ê–≥–µ–Ω—Ç 3 –∑–∞–ø—É—â–µ–Ω")
        logger.info(f"üì• –°–ª—É—à–∞—é –æ—á–µ—Ä–µ–¥—å: {self.config.QUEUE_INPUT}")  
        logger.info(f"üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é –≤ –æ—á–µ—Ä–µ–¥—å: {self.config.QUEUE_OUTPUT}")
        logger.info("üõë –ù–∞–∂–º–∏—Ç–µ Ctrl+C –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏\n")
        
        try:
            while True:
                try:
                    # –ë–ª–æ–∫–∏—Ä—É—é—â–µ–µ —á—Ç–µ–Ω–∏–µ –∏–∑ –æ—á–µ—Ä–µ–¥–∏ (timeout=1 —Å–µ–∫—É–Ω–¥–∞)
                    result = self.redis_client.blpop(self.config.QUEUE_INPUT, timeout=1)
                    
                    if result is None:
                        # –¢–∞–π–º–∞—É—Ç, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –∂–¥–∞—Ç—å
                        continue
                    
                    queue_name, message_data = result
                    logger.info(f"\nüì® –ê–≥–µ–Ω—Ç 3: –ü–æ–ª—É—á–µ–Ω–æ –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ {queue_name}")
                    
                    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
                    output = await self.process_message(message_data)
                    
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                    self.send_result(output)
                    
                    logger.info(f"‚úÖ –ê–≥–µ–Ω—Ç 3: –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ (–≤—Å–µ–≥–æ: {self.processed_count})\n")
                    
                except KeyboardInterrupt:
                    logger.info("\nüõë –ê–≥–µ–Ω—Ç 3: –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –æ—Å—Ç–∞–Ω–æ–≤–∫–∏")
                    break
                except Exception as e:
                    logger.error(f"‚ùå –ê–≥–µ–Ω—Ç 3: –ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: {e}")
                    await asyncio.sleep(1)
                    
        finally:
            await self.db.close_database()
            logger.info("üëã –ê–≥–µ–Ω—Ç 3 –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

# =========================
# –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
# =========================
async def test_agent_3():
    """–õ–æ–∫–∞–ª—å–Ω—ã–π —Ç–µ—Å—Ç –∞–≥–µ–Ω—Ç–∞ 3"""
    logger.info("=== –¢–ï–°–¢ –ê–ì–ï–ù–¢–ê 3 ===")
    
    config = Agent3Config()
    worker = Agent3RedisWorker(config)
    
    # –¢–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
    test_data = {
        "message": "–í—Å—Ç—É–ø–∞–π—Ç–µ –≤ –Ω–∞—à —á–∞—Ç! üéâ –¢–æ–ª—å–∫–æ —É –Ω–∞—Å –∫—Ä—É—Ç—ã–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è!",
        "rules": [
            "–ó–∞–ø—Ä–µ—â–µ–Ω–∞ —Ä–µ–∫–ª–∞–º–∞ —Å—Ç–æ—Ä–æ–Ω–Ω–∏—Ö —Å–æ–æ–±—â–µ—Å—Ç–≤",
            "–ó–∞–ø—Ä–µ—â—ë–Ω —Ñ–ª—É–¥ –∏ —Å–ø–∞–º",
            "–ó–∞–ø—Ä–µ—â–µ–Ω—ã –æ—Å–∫–æ—Ä–±–ª–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤"
        ],
        "user_id": 123456789,
        "username": "@test_user",
        "chat_id": -1001234567890,
        "message_id": 42
    }
    
    test_json = json.dumps(test_data, ensure_ascii=False)
    result = await worker.process_message(test_json)
    
    logger.info("–†–µ–∑—É–ª—å—Ç–∞—Ç:")
    print(json.dumps(result, ensure_ascii=False, indent=2))

# =========================
# –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞
# =========================
async def main():
    config = Agent3Config()
    worker = Agent3RedisWorker(config)
    await worker.run()

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1 and sys.argv[1] == "test":
        asyncio.run(test_agent_3())
    else:
        asyncio.run(main())